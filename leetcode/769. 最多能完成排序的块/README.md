我做此题时的思路如下。

首先针对对数组分块后块之间的性质进行分析。设共分为$n$块，每块记为$B_i,\space 1\le i\le n$。

对任意的两块$B_i,B_j,i<j,$满足如下条件
$$
max\{B_i\}<min\{B_j\}
$$
通俗一点来说，就是前面块中的**最大值**一定小于其后面块中的**最小值**。这个不难理解，可以采用反证法来证明。假设前面块中的最大值大于后面块中的最小值，那么对块分别排序后整体无法满足排序的要求，前面块中的最大值还是在后面块中的最小值的前面。这里还有边界情况需要考虑清楚，即上式中究竟是**小于**还是**小于等于**的。可以考虑一个极端情况，2,1,0,2，最后的2可以算在第一个块中，也可以独立成为第二个块，很显然让其独立可以取得最多的块。因此为小于。

有了以上分析，就可以得到具体的编码思路。我们记录$arr$中每个位置其右侧的最小值$dp$（包括自身）。然后遍历$arr$，对每个位置记录其左侧的最大值$tmp$（不包括自身）。这里的是否包括自身可以这样理解：因为记录最小值时包括了自身，所以在位置$i$时，小于$i$的部分为当前的块，大于等于$i$的部分未遍历。当且仅当$tmp\le dp[i]$时，我们认为到$i-1$的位置构成一个块，从$i$开始构成下一个块。代码如下：

```c++
class Solution {
public:
    int maxChunksToSorted(vector<int>& arr) {
        int n = arr.size();
        int ans = 1;
        // 右侧最小值（包括当前位置）
        int *dp = new int[n];
        dp[n-1] = arr[n-1];
        for (int i = n - 2; i >= 0; --i) {
            dp[i] = min(arr[i], dp[i+1]);
        }

        // 左侧最大值（不包括当前位置）
        int tmp = arr[0];
        for (int i = 1; i < n; ++i) {
            if (tmp <= dp[i]) {
                ++ans;
                tmp = arr[i];
            } else {
                tmp = max(tmp, arr[i]);
            }
        }

        return ans;
    }
};
```





